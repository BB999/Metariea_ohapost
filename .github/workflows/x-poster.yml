name: X (Twitter) Poster Module

on:
  workflow_call:
    inputs:
      tweet-text:
        required: true
        type: string
        description: "Tweet text content"
      image-file:
        required: false
        type: string
        description: "Image file path to attach"

jobs:
  post-to-x:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'
        
    - name: Download Image artifact (if needed)
      if: inputs.image-file != ''
      uses: actions/download-artifact@v4
      with:
        name: onedrive-images
        path: ./images/
        
    - name: Install Pillow for image compression
      if: inputs.image-file != ''
      run: pip install Pillow

    - name: Verify and Compress Image
      run: |
        echo "📋 ファイル確認中..."
        ls -la
        if [ "${{ inputs.image-file }}" != "" ]; then
          if [ -f "${{ inputs.image-file }}" ]; then
            echo "✅ 画像ファイル確認: ${{ inputs.image-file }}"
            file "${{ inputs.image-file }}"
            ORIGINAL_SIZE=$(stat -c%s "${{ inputs.image-file }}")
            echo "📊 元のファイルサイズ: $ORIGINAL_SIZE bytes ($(echo "scale=2; $ORIGINAL_SIZE/1024/1024" | bc) MB)"

            # 5MB (5242880 bytes) を超える場合は圧縮
            if [ $ORIGINAL_SIZE -gt 5242880 ]; then
              echo "🔄 画像が5MBを超えているため、JPEG圧縮を実行..."
              python3 scripts/compress_image.py "${{ inputs.image-file }}"

              # 圧縮後のファイルパスを環境変数に保存
              COMPRESSED_PATH="${{ inputs.image-file }}"
              COMPRESSED_PATH="${COMPRESSED_PATH%.*}.jpg"
              echo "COMPRESSED_IMAGE=$COMPRESSED_PATH" >> $GITHUB_ENV
              echo "📊 圧縮後ファイルサイズ: $(stat -c%s "$COMPRESSED_PATH") bytes"
            else
              echo "✅ 画像サイズは5MB以下なので圧縮不要"
              echo "COMPRESSED_IMAGE=${{ inputs.image-file }}" >> $GITHUB_ENV
            fi
          else
            echo "::error::❌ 画像ファイルが見つかりません: ${{ inputs.image-file }}"
            exit 1
          fi
        fi
        
    - name: Post to X (Twitter)
      env:
        X_API_KEY: ${{ secrets.X_API_KEY }}
        X_API_SECRET: ${{ secrets.X_API_SECRET }}
        X_ACCESS_TOKEN: ${{ secrets.X_ACCESS_TOKEN }}
        X_ACCESS_TOKEN_SECRET: ${{ secrets.X_ACCESS_TOKEN_SECRET }}
      run: |
        echo "🐦 X (Twitter) 投稿開始"
        echo ""
        echo "🔍 デバッグ情報:"
        echo "  - 受信したテキスト: '${{ inputs.tweet-text }}'"
        echo "  - テキストの長さ: $(echo -n '${{ inputs.tweet-text }}' | wc -c)"
        echo "  - 画像ファイル: '${{ inputs.image-file }}'"
        echo ""
        
        # テキストが空の場合のデフォルト設定
        TWEET_TEXT="${{ inputs.tweet-text }}"
        if [ -z "$TWEET_TEXT" ] || [ "$TWEET_TEXT" = "null" ]; then
          TWEET_TEXT="おはよう！素敵な一日を✨"
          echo "⚠️ テキストが空のため、デフォルトテキストを使用: $TWEET_TEXT"
        fi
        
        echo "📝 投稿するテキスト: $TWEET_TEXT"
        
        # Pythonスクリプトに渡すための環境変数設定
        export FINAL_TWEET_TEXT="$TWEET_TEXT"
        
        # 必要な環境変数のチェック
        if [ -z "$X_API_KEY" ] || [ -z "$X_API_SECRET" ] || [ -z "$X_ACCESS_TOKEN" ] || [ -z "$X_ACCESS_TOKEN_SECRET" ]; then
          echo "::error::❌ X API認証情報が設定されていません"
          echo "::error::以下のGitHub Secretsを設定してください:"
          echo "::error::  - X_API_KEY"
          echo "::error::  - X_API_SECRET"  
          echo "::error::  - X_ACCESS_TOKEN"
          echo "::error::  - X_ACCESS_TOKEN_SECRET"
          exit 1
        fi
        echo "✅ X API認証情報が設定されています"
        
        # Python投稿スクリプトを実行（v2 API対応版）
        python3 - <<'EOF'
        import os
        import sys
        import json
        import time
        import random
        import hmac
        import hashlib
        import base64
        import mimetypes
        import urllib.parse
        import urllib.request

        # 環境変数から認証情報を取得
        API_KEY = os.environ.get('X_API_KEY')
        API_SECRET = os.environ.get('X_API_SECRET')
        ACCESS_TOKEN = os.environ.get('X_ACCESS_TOKEN')
        ACCESS_TOKEN_SECRET = os.environ.get('X_ACCESS_TOKEN_SECRET')

        # 投稿内容
        TWEET_TEXT = os.environ.get('FINAL_TWEET_TEXT', "${{ inputs.tweet-text }}")
        # 圧縮後のファイルパスを優先して使用
        IMAGE_FILE = os.environ.get('COMPRESSED_IMAGE') or ("${{ inputs.image-file }}" if "${{ inputs.image-file }}" else None)

        def create_oauth_signature(method, url, params, api_secret, token_secret):
            """OAuth 1.0a 署名を生成"""
            sorted_params = sorted(params.items())
            param_string = '&'.join([f"{k}={v}" for k, v in sorted_params])
            signature_base = f"{method}&{urllib.parse.quote(url, safe='')}&{urllib.parse.quote(param_string, safe='')}"
            signing_key = f"{api_secret}&{token_secret}"
            signature = base64.b64encode(
                hmac.new(signing_key.encode(), signature_base.encode(), hashlib.sha1).digest()
            ).decode()
            return urllib.parse.quote(signature, safe='')

        def create_auth_header(method, url, extra_params=None):
            """OAuth 1.0a Authorization ヘッダーを生成"""
            oauth_params = {
                'oauth_consumer_key': API_KEY,
                'oauth_nonce': str(random.randint(0, 1000000000)),
                'oauth_signature_method': 'HMAC-SHA1',
                'oauth_timestamp': str(int(time.time())),
                'oauth_token': ACCESS_TOKEN,
                'oauth_version': '1.0'
            }
            sign_params = dict(oauth_params)
            if extra_params:
                sign_params.update(extra_params)
            oauth_params['oauth_signature'] = create_oauth_signature(
                method, url, sign_params, API_SECRET, ACCESS_TOKEN_SECRET
            )
            return 'OAuth ' + ', '.join([f'{k}="{v}"' for k, v in sorted(oauth_params.items())])

        def upload_media(file_path):
            """v2 API でメディアアップロード (INIT → APPEND → FINALIZE)"""
            file_size = os.path.getsize(file_path)
            mime_type = mimetypes.guess_type(file_path)[0] or 'application/octet-stream'
            print(f"📊 ファイル: {file_path} ({file_size} bytes, {mime_type})")

            # --- Step 1: INIT ---
            init_url = "https://api.x.com/2/media/upload/initialize"
            init_body = json.dumps({
                'media_type': mime_type,
                'total_bytes': file_size,
                'media_category': 'tweet_image'
            }).encode('utf-8')
            auth_header = create_auth_header('POST', init_url)
            req = urllib.request.Request(init_url, data=init_body, headers={
                'Authorization': auth_header,
                'Content-Type': 'application/json'
            })
            try:
                with urllib.request.urlopen(req) as response:
                    result = json.loads(response.read().decode())
                    media_id = result['data']['id']
                    print(f"✅ INIT成功: media_id={media_id}")
            except urllib.error.HTTPError as e:
                error_body = e.read().decode()
                print(f"❌ INIT失敗: {e.code} - {e.reason}")
                print(f"   詳細: {error_body}")
                return None
            except Exception as e:
                print(f"❌ INIT例外: {e}")
                return None

            # --- Step 2: APPEND ---
            append_url = f"https://api.x.com/2/media/upload/{media_id}/append"
            try:
                with open(file_path, 'rb') as f:
                    file_data = f.read()
                boundary = f'----WebKitFormBoundary{random.randint(1000000000, 9999999999)}'
                body_parts = []
                body_parts.append(f'--{boundary}')
                body_parts.append('Content-Disposition: form-data; name="media"; filename="upload"')
                body_parts.append(f'Content-Type: {mime_type}')
                body_parts.append('')
                body_prefix = '\r\n'.join(body_parts) + '\r\n'
                segment_part = f'\r\n--{boundary}\r\n'
                segment_part += 'Content-Disposition: form-data; name="segment_index"\r\n\r\n'
                segment_part += '0'
                segment_suffix = f'\r\n--{boundary}--\r\n'
                body = body_prefix.encode() + file_data + segment_part.encode() + segment_suffix.encode()
                auth_header = create_auth_header('POST', append_url)
                req = urllib.request.Request(append_url, data=body, headers={
                    'Authorization': auth_header,
                    'Content-Type': f'multipart/form-data; boundary={boundary}'
                })
                with urllib.request.urlopen(req) as response:
                    print(f"✅ APPEND成功")
            except urllib.error.HTTPError as e:
                error_body = e.read().decode()
                print(f"❌ APPEND失敗: {e.code} - {e.reason}")
                print(f"   詳細: {error_body}")
                return None
            except Exception as e:
                print(f"❌ APPEND例外: {e}")
                return None

            # --- Step 3: FINALIZE ---
            finalize_url = f"https://api.x.com/2/media/upload/{media_id}/finalize"
            auth_header = create_auth_header('POST', finalize_url)
            req = urllib.request.Request(finalize_url, data=b'', headers={
                'Authorization': auth_header,
            })
            try:
                with urllib.request.urlopen(req) as response:
                    result = json.loads(response.read().decode())
                    print(f"✅ FINALIZE成功: media_id={media_id}")
                    processing = result.get('data', {}).get('processing_info')
                    if processing and processing.get('state') not in ('succeeded', None):
                        print(f"⏳ メディア処理中...")
                    return media_id
            except urllib.error.HTTPError as e:
                error_body = e.read().decode()
                print(f"❌ FINALIZE失敗: {e.code} - {e.reason}")
                print(f"   詳細: {error_body}")
                return None
            except Exception as e:
                print(f"❌ FINALIZE例外: {e}")
                return None

        def post_tweet(text, image_file):
            """ツイート投稿"""
            url = "https://api.x.com/2/tweets"

            # メディアアップロード
            uploaded_media_ids = []
            if image_file and os.path.exists(image_file):
                print(f"📤 画像アップロード中: {image_file}")
                media_id = upload_media(image_file)
                if media_id:
                    uploaded_media_ids.append(media_id)
                else:
                    print(f"⚠️ 画像アップロードに失敗、テキストのみで投稿を続行")

            # リクエストボディ
            tweet_data = {'text': text}
            if uploaded_media_ids:
                tweet_data['media'] = {'media_ids': uploaded_media_ids}
                print(f"📎 メディア添付: {len(uploaded_media_ids)}個")

            body = json.dumps(tweet_data).encode('utf-8')
            auth_header = create_auth_header('POST', url)
            req = urllib.request.Request(url, data=body, headers={
                'Authorization': auth_header,
                'Content-Type': 'application/json'
            })

            try:
                with urllib.request.urlopen(req) as response:
                    result = json.loads(response.read().decode())
                    print(f"✅ ツイートを投稿しました: {text}")
                    if uploaded_media_ids:
                        print(f"   メディア: {len(uploaded_media_ids)}個のファイル")
                    print(f"   ツイートID: {result['data']['id']}")
                    print(f"   URL: https://x.com/i/web/status/{result['data']['id']}")
                    return True
            except urllib.error.HTTPError as e:
                error_body = e.read().decode()
                print(f"❌ ツイート投稿エラー: {e.code} - {e.reason}")
                print(f"   詳細: {error_body}")
                return False

        # メイン処理
        if not all([API_KEY, API_SECRET, ACCESS_TOKEN, ACCESS_TOKEN_SECRET]):
            print("❌ 認証情報が不足しています")
            sys.exit(1)

        success = post_tweet(TWEET_TEXT, IMAGE_FILE)
        sys.exit(0 if success else 1)
        EOF
        
        echo ""
        echo "🎉 X投稿処理が完了しました"